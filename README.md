# sql-arch

# 데이터베이스 설계의 첫걸음

## 1️⃣ 설계의 중요성

* 데이터베이스 설계는 시스템의 **뼈대(설계도)** 를 만드는 과정.
* 초기에는 빠르지만, 설계 없이 구축하면 시간이 지날수록 **중복, 성능 저하, 유지보수 어려움** 발생.
* 체계적 설계는 데이터 무결성과 효율성을 높이는 **정규화 과정**을 포함.
* 잘된 설계 = 변화에 유연하고, 확장 가능한 시스템 기반.

---

## 2️⃣ 잘못된 설계의 문제

| 문제 유형          | 설명                              |
| -------------- | ------------------------------- |
| **데이터 무결성 훼손** | 중복 데이터로 인해 불일치 발생 (수정/삽입/삭제 이상) |
| **성능 저하**      | 불필요한 데이터 누적으로 조회 속도 감소          |
| **유지보수 비용 증가** | 작은 변경에도 테이블 구조 전체 수정 필요         |

### 🔹 이상 현상(Anomaly) 예시

* **수정 이상**: 한 정보 변경 시 여러 곳 수정 필요 → 누락 시 불일치 발생.
* **삽입 이상**: 불필요한 데이터 없이는 원하는 정보 입력 불가.
* **삭제 이상**: 특정 정보 삭제 시, 다른 중요한 정보까지 함께 삭제.

---

## 3️⃣ 데이터베이스 설계 3단계

| 단계              | 설명                                 | 주요 산출물                           |
| --------------- | ---------------------------------- | -------------------------------- |
| **1단계: 개념적 설계** | 비즈니스 요구사항 분석, 핵심 데이터(엔티티)와 관계 파악   | ERD(Entity Relationship Diagram) |
| **2단계: 논리적 설계** | 정규화 수행, 테이블 구조·PK·FK 정의 (DBMS 독립적) | 논리 모델 (테이블 정의서)                  |
| **3단계: 물리적 설계** | 특정 DBMS에 맞게 최적화, 컬럼 타입·인덱스 결정      | CREATE TABLE 스크립트                |

> 각 단계는 관점이 다르지만, 실무에서는 종종 혼용되어 사용됨.

---

## ✅ 요약

* 데이터베이스 설계 = **데이터 품질과 성능의 출발점**.
* 정규화를 통해 **중복 제거·무결성 확보**.
* 개념 → 논리 → 물리 설계의 3단계를 거치며, 변화에 강한 DB 구조 완성.

---

# 개념적 모델링

## 1️⃣ 개념적 모델링의 목적

* 기술적 용어 대신 **비즈니스 관점에서 모두가 이해 가능한 데이터 청사진**을 만드는 과정.
* 요구 사항 분석 시 **명사 → 엔티티**, **동사 → 관계**로 식별.
* 시스템이 저장·관리해야 할 ‘대상’을 엔티티로 도출.

---

## 2️⃣ 엔티티(Entity)

* 데이터를 저장하고 관리해야 할 **유무형의 대상** → 데이터베이스의 **테이블**에 해당.
* 좋은 엔티티의 특징:

    * 업무 관련성, 식별 가능성, 2개 이상 속성 보유, 인스턴스의 집합, 관계 보유.
* 엔티티 = 개념적 틀(시트), 인스턴스 = 실제 데이터 행.

---

## 3️⃣ 엔티티 분류

| 기준         | 유형               | 설명                 |
| ---------- | ---------------- | ------------------ |
| **존재 형태**  | 유형 / 개념 / 사건 엔티티 | 실체, 추상 개념, 행위 기록 등 |
| **역할·시점**  | 기본 / 중심 / 행위 엔티티 | 데이터 흐름 및 우선순위 결정   |
| **존재 종속성** | 강한 / 약한 엔티티      | 독립적 존재 vs 부모 의존    |

* **사건·행위 엔티티**는 데이터 증가가 빠르므로, 인덱스·파티셔닝·아카이빙 고려 필요.
* **연관 엔티티**: 다대다(M:N) 관계를 1:N 두 개로 분리하여 추가 속성 저장 가능.
* **슈퍼타입/서브타입**: 공통 속성과 차이를 구조적으로 표현.

---

## 4️⃣ 속성과 식별자

* **속성(Attribute)**: 엔티티의 구체적 정보 → 컬럼(Column).
* **식별자(Identifier)**: 각 인스턴스를 구분하는 고유 속성 → 기본 키(PK).

---

## 5️⃣ 관계의 세부 요소

| 요소                     | 설명                                             |
| ---------------------- | ---------------------------------------------- |
| **카디널리티(Cardinality)** | 한 엔티티 인스턴스가 다른 엔티티와 맺는 최대 관계 수 (1:1, 1:N, M:N) |
| **참여도(Optionality)**   | 관계 참여가 필수(Mandatory)인지 선택(Optional)인지          |

---

## 6️⃣ ERD(Entity-Relationship Diagram)

* 엔티티, 속성, 관계를 **시각적으로 표현**한 데이터 구조 청사진.
* **Crow’s Foot 표기법**이 표준: 선의 끝기호로 **카디널리티 + 참여도** 표현.

---

## 7️⃣ 연관 엔티티 (Associative Entity) — M:N 관계 해결
![related-entity.png](img/related-entity.png)
* **M:N 관계의 문제점:**

    * 관계형 DB에서는 M:N 관계를 물리적으로 구현할 수 없음.
    * 관계 자체에 속한 정보(예: 주문수량, 주문가격)를 저장할 공간이 없음.
* **잘못된 설계 예:**

    * 여러 상품 ID 컬럼을 추가하거나 한 컬럼에 여러 값을 넣는 경우 → **확장성, 원자성, 검색성 모두 악화**.
* **해결책:**

    * M:N 관계를 새로운 엔티티로 승격시켜 **두 개의 1:N 관계로 분리.**
    * 예: `주문(Order)` ↔ `주문_항목(Order_Item)` ↔ `상품(Product)`
    * `주문_항목` 테이블에 `주문수량`, `주문가격` 등의 관계 속성을 저장.
* **실무 용어:** 연결 테이블(Link Table), 조인 테이블(Join Table), 매핑 테이블(Mapping Table).
* **핵심:** 모든 M:N 관계는 현실적으로 **연관 엔티티로 해소**되어야 하며, 관계 시점의 속성을 반드시 찾아야 한다.

---

## 8️⃣ 용어 사전 (Data Dictionary)

* 비즈니스 용어 ↔ DB 객체명을 일관되게 관리하는 문서.
* `회원(member)`, `가격(price)` 등 **단일어 중심 정의** 후 조합 사용.
* 프로젝트 진행 중 **지속적 업데이트되는 살아있는 문서.**

---

## ✅ 핵심 요약

* 개념적 모델링 = **데이터 세상의 설계도**.
* 명사 → 엔티티, 동사 → 관계.
* 엔티티·속성·관계·식별자·카디널리티를 명확히 정의해 **ERD로 시각화**.
* **M:N 관계는 반드시 연관 엔티티로 해소하여 관계 속성까지 관리.**
* 용어 사전은 조직 내 **공통 언어 체계**를 구축하는 핵심 도구.
